{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"All Workshops","text":"<p>All Workshops</p>"},{"location":"intro_to_single_cell_rnaseq/00_background/","title":"Schedule","text":""},{"location":"intro_to_single_cell_rnaseq/00_background/#introduction-to-single-cell-rna-seq-bioinformatics","title":"Introduction To Single-Cell RNA-Seq Bioinformatics","text":"<p>In this workshop we\u00a0will introduce single-cell RNA sequencing and the bioinformatics methods that are used to analyze the data. We will cover common computational algorithms for quality control and clustering\u00a0as\u00a0well as give participants hands on experience in analyzing single-cell RNA sequencing data with\u00a0open source bioinformatics tools.</p> <p>Prerequisites</p> <ul> <li>Request an account on the Tufts HPC Cluster. Note if you signed up for the Introduction to Single-Cell RNA-Seq workshop this will have been already taken care of for you!</li> <li>Connect to the VPN if off campus</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/00_background/#schedule","title":"Schedule","text":""},{"location":"intro_to_single_cell_rnaseq/00_background/#day-1","title":"Day 1","text":"Time Topic Instructor 02:00 - 03:00 Lecture: Quality Control, Integration, Clustering Dr. Eric Reed 03:00 - 04:00 Hands on Workshop"},{"location":"intro_to_single_cell_rnaseq/00_background/#day-2","title":"Day 2","text":"Time Topic Instructor 02:00 - 03:00 Cell-type identification and Differential Expression Dr. Rebecca Batorsky 03:00 - 04:00 Hands on Workshop <p>Brought to you by Data Intensive Studies Center. Please email disc@tufts.edu with questions.</p> <ul> <li>Rebecca Batorsky, PhD, Data Scientist</li> <li>Eric Reed, PhD, Data Scientist</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/01_setup/","title":"Setting up your work on the Tufts High Performance Compute (HPC) Cluster","text":"<p>Prerequisites</p> <ul> <li>Request an account on the Tufts HPC Cluster. Note if you signed up for the Introduction to Single-Cell RNA-Seq workshop this will have been done for you.</li> <li>Connect to the VPN if off campus</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/01_setup/#navigate-to-the-cluster","title":"Navigate To The Cluster","text":"<p>Once you have an account and are connected to the VPN/Tufts Network, navigate to the OnDemand Website and log in with your tufts credentials. Once you are logged in you'll notice a few navigation options:</p> <p>OnDemand Layout</p> <p></p> <p>Click on <code>Interactive Apps &gt; RStudio Pax</code> and you will see a form to fill out to request compute resources to use RStudio on the Tufts HPC cluster. We will fill out the form with the following entries:</p> <ul> <li><code>Number of hours</code> : <code>5</code></li> <li><code>Number of cores</code> : <code>1</code></li> <li><code>Amount of memory</code> : <code>16GB</code></li> <li><code>R version</code> : <code>4.0.0</code></li> <li><code>Reservation for class, training, workshop</code> : <code>Bioinformatics Workshops</code><ul> <li>NOTE: This reservation will be available for registered participants only on Oct 26th and Nov 2nd 2023, use <code>Default</code> in all other cases.</li> </ul> </li> </ul> <p>Click <code>Launch</code> and wait until your session is ready. Click <code>Connect To RStudio Server</code>, and a new tab will open with Rstudio. </p> <p></p> Are you connected to RStudio? <ul> <li>Yes (put up a green check mark in zoom)</li> <li>No (raise hand in zoom)</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/01_setup/#data-scripts","title":"Data &amp; Scripts","text":"<p>To copy over the data and scripts we will need for the workshop into our home directory, enter the following command into the Console in the lower left and press enter. </p> <pre><code>file.copy(from=\"/cluster/tufts/bio/tools/training/intro_to_scrnaseq\",to=\"~/\", recursive = TRUE)\n</code></pre> <p>To see that our folder was copied over, we'll refresh our file list in the lower right hand Rstudio pane by clicking the <code>refresh</code> arrow . </p> <p>To open our first workshop script:</p> <ul> <li> <p>Click on the <code>Files</code> tab in the lower right hand Rstudio pane</p> </li> <li> <p>Click on the <code>intro_to_scrnaseq</code> directory</p> </li> <li> <p>Click on the <code>scripts</code> folder</p> </li> <li> <p>Click on the <code>02_formatting.Rmd</code> script</p> </li> </ul>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/","title":"Single Cell RNA Sequencing Data Structures in R","text":"<p>In this section we will describe the common data structures of singe cell RNA sequencing data (scRNAseq) data and how to read in and manipulate these data in R, specifically using the <code>Seurat</code> package. Furthermore, we will demonstrate how to read-in and merge multiple data sets. Portions of this section have been adapted from a previous Tufts HPC workshop.</p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#the-data","title":"The Data","text":"<p>For this workshop we will be working with a scRNAseq dataset which is part of a larger study from Kang et al, 2017. The data is comprised of pooled Peripheral Blood Mononuclear Cells (PBMCs) taken from lupus patients, split into control and interferon beta-treated (stimulated) conditions. The counts for this dataset is freely available from 10X Genomics and is used as part of a Seurat tutorial.</p> <p>Since they comprise PBMCs, we expect these data to include mononuclear immune cells, such as</p> <ul> <li>B cells</li> <li>T cells</li> <li>Natural killer cells</li> <li>Monocytes</li> <li>Macrophages</li> </ul> <p>and exclude polymorphonuclear immune cell types (neutrophils) and  nucleus lacking blood cells (erythrocytes and platelets).</p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#setting-up-r-environment","title":"Setting up R environment","text":""},{"location":"intro_to_single_cell_rnaseq/02_formatting/#r-library-source","title":"R library source","text":"<p>This workshop requires a series of R libraries. In order to load these libraries we will first set their path in our R environment.</p> <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#read-in-r-packages","title":"Read in R packages","text":"<p>For this section, requires three R packages:</p> <ol> <li><code>Seurat</code> : A package for working with and analysis of scRNAseq data. Comprehensive tutorials for available analyses with the <code>Seurat</code> R package are available on the project website.</li> <li><code>Matrix</code>: A package for working with large data matrices.</li> <li><code>tidyverse</code> : Actually a compendia of packages, which include functionality for \"tidy\" data wrangling.</li> </ol> <pre><code>library(Seurat)\nlibrary(Matrix)\nlibrary(tidyverse)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#set-base-directory","title":"Set base directory","text":"<p>We will be reading in and writing files relative to our <code>intro_to_scrnaseq</code>. For simplicity, we will create an R object that is simply a character string that gives this path, and use it as a prefix for reading and writing files.</p> <pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#scrnaseq-count-files","title":"scRNAseq count files","text":"<p>Following pre-processing of raw files, scRNAseq count data is generally stored in directories containing three files. In this workshop will be working with two scRNAseq count data sets for each of our two condition, stored in two directories:</p> <ol> <li><code>ctrl_raw_feature_bc_matrix</code> : Control PBMCs</li> <li><code>stim_raw_feature_bc_matrix</code> : Interferon beta-treated (stimulated) PBMCs</li> </ol> <p>Each directory contains our count data as three compressed files:</p> <ol> <li><code>barcodes.tsv.gz</code></li> <li><code>features.tsv.gz</code></li> <li><code>matrix.mtx.gz</code></li> </ol> <p>Next, we will read in describe each file in the <code>ctrl_raw_feature_bc_matrix</code> directory.</p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#barcodestsvgz","title":"<code>barcodes.tsv.gz</code>","text":"<p>This is a text file which contains all cellular barcodes present for that sample. Barcodes are listed in the order of data presented in the matrix file (i.e. these are the column names).</p> <pre><code>barcodes &lt;- read.delim(file.path(baseDir, \"data/ctrl_raw_feature_bc_matrix/barcodes.tsv.gz\"), header=F)\nhead(barcodes)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#featurestsvgz","title":"<code>features.tsv.gz</code>","text":"<p>This is a text file which contains the identifiers of the quantified genes. The source of the identifier can vary depending on what reference (i.e. Ensembl, NCBI, UCSC) you use in the quantification methods, but most often these are official gene symbols. The order of these genes corresponds to the order of the rows in the matrix file (i.e. these are the row names).</p> <pre><code>features &lt;- read.delim(file.path(baseDir, \"data/ctrl_raw_feature_bc_matrix/features.tsv.gz\"), header=F)\nhead(features)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#matrixmtxgz","title":"<code>matrix.mtx.gz</code>","text":"<p>This is a text file which contains a matrix of count values. The rows are associated with the gene IDs above and columns correspond to the cellular barcodes. Note that there are many zero values in this matrix.</p> <p>Note, we will read this file in R, using the <code>readMM()</code> function from the <code>Matrix</code> package. This will create a \"sparse matrix\" which is formatted to save space due the redundancy of 0 values. When we view this object, 0 values are shown as \".\"s. Below, we print the first ten rows and columns.</p> <pre><code>matrix &lt;- readMM(file.path(baseDir, \"data/ctrl_raw_feature_bc_matrix/matrix.mtx.gz\"))\nmatrix[1:10, 1:10]\n</code></pre> <p></p> <p>Based on the dimensions of this object, we see that there are 33,538 genes (rows), and 737,280 samples (columns) in these data.</p> <pre><code>dim(matrix)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#creating-seurat-objects","title":"Creating Seurat objects","text":"<p>As previously mentions, in this workshop, we are going to perform the bulk of scRNAseq data manipulation and analysis using the <code>Seurat</code> R package. To this end, we are going to start by reading in the data to a <code>Seurat</code> object. A <code>Seurat</code> object has a specific data structure, for which functionality of the <code>Seurat</code> R package is built around for performing various procedures with our scRNAseq data.</p> <p>This can be performed in two steps.</p> <p>First, we use the <code>Read10X()</code> function from the <code>Seurat</code> package to load our scRNAseq data into R. This function assumes that our data is stored in a directory containing our three files, <code>barcodes.tsv.gz</code>, <code>features.tsv.gz</code>, <code>matrix.mtx.gz</code>, which is the standard for scRNAseq data generated by 10X Genomics. Thus, rather than reading in each file individually, we only need to set the path to the directory.</p> <pre><code>ctrl_counts &lt;- Read10X(data.dir = file.path(baseDir, \"data/ctrl_raw_feature_bc_matrix\"))\n</code></pre> <p>Second, we use the <code>CreateSeuratObject()</code> function to convert the data as a <code>Seurat</code> object. Additionally, when we implement this function, we perform an initial data processing step by setting <code>min.features = 100</code>. This will remove cell profiles for which there are fewer than 100 genes with counts greater than 0.</p> <pre><code>ctrl &lt;- CreateSeuratObject(counts = ctrl_counts,\n                           min.features = 100)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#seurat-object-structure","title":"Seurat object  structure","text":"<p>Basic features of a <code>Seurat</code> object can be viewed by simply calling the object itself.</p> <p>For example, viewing the object output we can see that after filtering low coverage samples, we are left with 15,688 cell profiles. Which is only about 2% of the total in the raw count matrix file.</p> <pre><code>ctrl\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#expression-data-assays","title":"Expression data \"assays\"","text":"<p>Note that as part of the output we see the term \"Active assay: RNA\". In <code>Seurat</code> objects, expression data is organized into these \"assays\", where each assay is a container of which different states of the expression data are stored separately. Every assay contains three \"slots\":</p> <ul> <li><code>RNA</code> assay<ul> <li><code>count</code></li> <li><code>data</code></li> <li><code>scale.data</code></li> </ul> </li> </ul>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#the-count-slot","title":"The <code>count</code> slot","text":"<p>The <code>count</code> slot always contains the expression data as counts as a sparse matrix. Below are a couple of examples for accessing these data from the Seurat object.</p> <pre><code>countSlot &lt;- ctrl@assays$RNA@counts[1:5, 1:5]\ncountSlot &lt;- GetAssayData(ctrl, slot = \"counts\")[1:5, 1:5]\ncountSlot[1:5, 1:5]\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#the-data-slot","title":"The <code>data</code> slot","text":"<p>The purpose of the <code>data</code> slot is to store normalized data. We will perform normalization procedures later in this workshop, and this is commonly performed using the <code>NormalizeData()</code> <code>Seurat</code> function. However, since no normalization has been performed, the <code>data</code> slot is currently identical to the <code>count</code> slot.</p> <pre><code>dataSlot &lt;- ctrl@assays$RNA@data\ndataSlot &lt;- GetAssayData(ctrl, slot = \"data\")\ndataSlot[1:5, 1:5]\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#the-scaledata-slot","title":"The <code>scale.data</code> slot","text":"<p>Numerous analytic procedures are best suited for data that has been scaled, such that the mean expression of every genes is equal to 0 with standard deviation equal to 1. This procedure is generally performed on normalized data, and the resulting \"scaled\" data is stored in the <code>scale.data</code> slot. Accordingly, right now this slot is an empty matrix.</p> <pre><code>scalSlot &lt;- ctrl@assays$RNA@scale.data\nscalSlot &lt;- GetAssayData(ctrl, slot = \"scale.data\")\nscalSlot\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#seurat-objects-with-multiple-assays","title":"<code>Seurat</code> objects with multiple assays","text":"<p>To prevent overwriting data or necessitating the creation of multiple <code>Seurat</code> objects, various procedures will create new assays for storing data. For example, later in this workshop we will perform a procedure, using the <code>SCTransform()</code> function (detailed later), which creates a new assay and the resulting assay structure of the <code>Seurat</code> object will have an assay structure:</p> <ul> <li>RNA assay<ul> <li>count</li> <li>data</li> <li>scale.data</li> </ul> </li> <li>SCT assay<ul> <li>count</li> <li>data</li> <li>scale.data</li> </ul> </li> </ul> <p>We can list the available assays that have been created using the <code>Assays()</code> <code>Seurat</code> function. More importantly we can set the default assay using the <code>DefaultAssay()</code> function. This is good practice when working with <code>Seurat</code> objects containing multiple assays, to ensure that specific procedures are performed on the data for which they are intended.</p> <pre><code>Assays(ctrl)\nDefaultAssay(ctrl) &lt;- \"RNA\"\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#cell-profile-metadata","title":"Cell profile metadata","text":"<p>In <code>Seurat</code> objects, the \"metadata\" refers to a data frame, in which we store additional information for each cell profile.</p> <p>We can access this data from the <code>Seurat</code> object in a number of ways. For example, below we show two ways of accessing the entire metadata data frame.</p> <pre><code>metaData &lt;- ctrl[[]]\nmetaData &lt;- ctrl@meta.data\nhead(metaData)\n</code></pre> <p></p> <p>Here, the rows are in the same order as the expression matrix, which allows use to index the expression data based on this information. </p> <p>By default, the <code>CreateSeuratObject()</code> function creates three columns in the meta.data</p> <ul> <li><code>orig.ident</code>: An identifier for the data set</li> <li><code>nCount_RNA</code>: The total number of counts each cell profile</li> <li><code>nFeature_RNA</code>: The total number of genes with counts &gt; 0. </li> </ul> <p>In addition to all columns there are a number of ways to extract specific columns in the metadata directly from the <code>Seurat</code> object. For example, here are two ways we can extract the <code>nCount_RNA</code> column from the metadata.</p> <p><pre><code>nCount &lt;- ctrl$nCount_RNA\nnCount &lt;- ctrl@meta.data$nCount_RNA\nhead(nCount)\n</code></pre> </p> <p>Alternatively, there are many ways to extract multiple metadata columns from the <code>Seurat</code> object.</p> <p><pre><code>multCols &lt;- ctrl@meta.data[, c(\"nCount_RNA\", \"nFeature_RNA\")]\nmultCols &lt;- ctrl[[c(\"nCount_RNA\", \"nFeature_RNA\")]]\nhead(multCols)\n</code></pre> </p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#combining-data-sets","title":"Combining data sets","text":"<p>It is common for scRNAseq projects to include multiple samples profiled separately. In our case we have two separate data sets, comprising profiles from \"control\" and \"stimulated\" PBMC samples. Accordingly, we're going to combine these data into a single <code>Seurat</code> object, while assigning information as to their source in the metadata.</p> <p>Here, we use a <code>for</code> loop to read in each of the two data sets. Within each we assign an identity to each data set using the <code>project</code> argument.</p> <pre><code>for (file in c(\"ctrl_raw_feature_bc_matrix\", \"stim_raw_feature_bc_matrix\")){\n  seurat_data &lt;- Read10X(data.dir = file.path(baseDir, \"data\", file))\n  seurat_obj &lt;- CreateSeuratObject(counts = seurat_data, \n                                   min.features = 100, \n                                   project = file)\n  assign(file, seurat_obj)\n}\n</code></pre> <p>We have just created two <code>Seurat</code> objects, <code>ctrl_raw_feature_bc_matrix</code> and <code>stim_raw_feature_bc_matrix</code>. And if we check the metadata of <code>ctrl_raw_feature_bc_matrix</code> to see that its source has been saved in the <code>orig.identity</code> column.</p> <pre><code>head(ctrl_raw_feature_bc_matrix@meta.data)\n</code></pre> <p></p> <p>Finally, we merge the two <code>Seurat</code> objects with the <code>merge()</code> function below. Since each data set will contain likely some of the same cell profile identifiers, e.g. \"AAACATACAATGCC-1\", we add a prefix to these identifiers using the <code>add.cell.id</code> argument.</p> <pre><code>merged_seurat &lt;- merge(x = ctrl_raw_feature_bc_matrix, \n                       y = stim_raw_feature_bc_matrix, \n                       add.cell.id = c(\"ctrl\", \"stim\"))\n</code></pre> <p>Using the <code>orig.identity</code> column we can check how many cell profiles from each data set are contained in the merged data set.</p> <pre><code>table(merged_seurat@meta.data$orig.ident)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#adding-metadata-for-downstream-analyses","title":"Adding metadata for downstream analyses","text":"<p>Now that we have the fully merged scRNAseq data, we will add a couple additional columns to our metadata, which we will later use for quality control. These columns comprise calculations of two metrics, which are indicative the quality of individual cell profiles.</p> <ul> <li>Novelty score: this metric with give us an idea of the complexity of our dataset (more genes detected per UMI, more complex our data).</li> <li>Percent mitochondrial UMI: this metric will give us a percentage of cell reads originating from the mitochondrial genes</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#novelty-score","title":"Novelty score","text":"<p>This value is quite easy to calculate, as we take the log10 of the number of genes detected per cell and the log10 of the number of UMIs per cell, then divide the log10 number of genes by the log10 number of UMIs. The novelty score and how it relates to complexity of the RNA species, is described in more detail later in this lesson.</p> <pre><code>merged_seurat$log10GenesPerUMI &lt;- log10(merged_seurat$nFeature_RNA) / log10(merged_seurat$nCount_RNA)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#percent-mitochondrial-umi","title":"Percent mitochondrial UMI","text":"<p>Seurat has a convenient function that allows us to calculate the **proportion of transcripts mapping to mitochondrial genes(. The <code>PercentageFeatureSet()</code> function takes in a pattern argument and searches through all gene identifiers in the dataset for that pattern. Since we are looking for mitochondrial genes, we are searching any gene identifiers that begin with the pattern \"MT-\". For each cell, the function takes the sum of counts across all genes (features) belonging to the \"Mt-\" set, and then divides by the count sum for all genes (features). This value is multiplied by 100 to obtain a percentage value.</p> <pre><code>merged_seurat$percMitoUMI &lt;- PercentageFeatureSet(object = merged_seurat, pattern = \"^MT-\")\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#finishing-touches","title":"Finishing touches","text":"<p>Finally, we will make a few additional changes to our metadata to facilitate downstream analyses.</p> <p>First, we will create a new metadata column with simplified identifers for each of the merged data sets. We can do this easily, by taking the first 4 characters of the values from the <code>orig.identity</code> column, and assigning them to a new column.</p> <pre><code>merged_seurat$sample &lt;- substr(merged_seurat@meta.data$orig.ident, 1, 4)\n\ntable(merged_seurat$sample)\n</code></pre> <p></p> <p>Next, we will rename several of metadata column names short, so they are shorter and more intuitive (to us at least).</p> <pre><code>merged_seurat@meta.data &lt;- merged_seurat@meta.data %&gt;%\n  dplyr::rename(seq_folder = orig.ident,\n                nUMI = nCount_RNA,\n                nGene = nFeature_RNA)\n</code></pre> <p>Lastly we can check the final formatted metadata dataframe with all of our newly added and formatted metadata columns. These are a lot of columns to view in our console and html output, so we'll just use the <code>View()</code> R function.</p> <pre><code>View(merged_seurat@meta.data)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/02_formatting/#save-seurat-object","title":"Save seurat object","text":"<p>That's it! At this point, we can save our merged data set and move on to quality control.</p> <pre><code>saveRDS(merged_seurat, file.path(baseDir, \"results/merged_seurat.rds\"))\n</code></pre> <p>You can now open \"03_quality_control.Rmd\" to continue on the the next section.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/","title":"Single Cell RNA Sequencing Quality Control","text":"<p>In this section we will describe strategies for filtering out \"low-quality\" cell profiles from scRNAseq data. We will perform quality control our two-sample combined and formatted PBMC scRNAseq data set [<code>Seurat</code>] object generated in the previous section. Portions of this section have been adapted from a previous Tufts HPC workshop.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#setting-up-r-environment","title":"Setting up R environment","text":"<p>We begin by setting up our R environment similar to the previous section.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#r-library-source","title":"R library source","text":"<p>We will be reading in and writing files relative to our <code>intro_to_scrnaseq</code>. For simplicity, we will create an R object that is simply a character string that gives this path, and use it as a prefix for reading and writing files.</p> <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#read-in-r-packages","title":"Read in R packages","text":"<p>For this section, requires three R packages:</p> <ol> <li><code>Seurat</code> : A package for working with and analysis of scRNAseq data. Comprehensive tutorials for available analyses with the <code>Seurat</code> R package are available on the project website.</li> <li><code>ggplot2</code>: The standard package for creating plots in R. Much of the plotting functions are wrappers for <code>ggplot2</code> functionality.</li> <li><code>cowplot</code> : A nice package for combining plots into a single figure. Specifically we will make use of of the <code>plot_grid()</code> function.</li> </ol> <pre><code>library(Seurat)\nlibrary(ggplot2)\nlibrary(cowplot)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#set-base-directory","title":"Set base directory","text":"<pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#read-in-combined-and-formatted-pbmc-seurat-object","title":"Read in combined and formatted PBMC <code>Seurat</code> object","text":"<pre><code>merged_seurat &lt;- readRDS(file.path(baseDir, \"results/merged_seurat.rds\"))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#quality-control-filtering","title":"Quality Control Filtering","text":"<p>Now that we have generated the various metrics to assess, we can explore them with visualizations. We will assess various metrics and then decide on which cells are low quality and should be removed from the analysis:</p> <ul> <li>Metric : Metadata Column</li> <li>UMI counts per cell : nUMI</li> <li>Genes detected per cell : nGene</li> <li>Complexity (novelty score) : log10GenesPerUMI</li> <li>Percent mitochondrial UMI : percentMitoUMI</li> </ul>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#umi-counts-transcripts-per-cell","title":"UMI counts (transcripts) per cell","text":"<p>The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable, but these cells can more prone to misidentification downstream due to their lower molecular resolution.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#genes-detected-per-cell","title":"Genes detected per cell","text":"<p>We have similar expectations for gene detection as for UMI detection, although it may be a bit lower than UMIs. For high quality data, the probability density should contain a single large peak that represents cells that were encapsulated. If we see a small shoulder to the left of the major peak (not present in our data), or a bimodal distribution of the cells, that can indicate a couple of things. It might be that there are a set of cells that failed for some reason. It could also be that there are biologically different types of cells (i.e. quiescent cell populations, less complex cells of interest), and/or one type is much smaller than the other (i.e. cells with high counts may be cells that are larger in size). Therefore, this threshold should be assessed with other metrics that we describe in this lesson.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#complexity","title":"Complexity","text":"<p>We can evaluate each cell in terms of how complex the RNA species are by using a measure called the novelty score. The novelty score is computed by taking the ratio of log10 of the number of genes detected per cell and the log10 of the number of UMIs per cell. If there are many captured transcripts (high nUMI) and a low number of genes detected in a cell, this likely means that you only captured a low number of genes and simply sequenced transcripts from those lower number of genes over and over again. These low complexity (low novelty) cells could represent a specific cell type (i.e. red blood cells which lack a typical transcriptome), or could be due to an artifact or contamination. Generally, we expect the novelty score to be above 0.80 for good quality cells.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#percent-mitochondrial-umis","title":"Percent mitochondrial UMIs","text":"<p>This metric can identify whether there is a large amount of mitochondrial contamination from dead or dying cells. We define poor quality samples for mitochondrial counts as cells which surpass the 20% percent mitochondrial unless of course you are expecting this in your sample.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#visualize-quality-control-metrics","title":"Visualize quality control metrics","text":"<p>We begin by visualizing our four quality control metrics using the <code>VlnPlot()</code> function from the <code>Seurat</code> package. This will show us the general distribution of values for each variable and offer a visual comparison of these distributions between our two samples. Moreover, we will visualize our thresholds for filtering. To recap, we will keep cell profiles that pass the following criteria.</p> <ul> <li>nUMI &gt; 500</li> <li>nGene &gt; 250</li> <li>log10GenesPerUMI &gt; 0.8</li> <li>percMitoUMI &lt; 20</li> </ul> <pre><code># Plot UMI counts per cell\nPnUMI &lt;- VlnPlot(object = merged_seurat, \n        features = \"nUMI\",\n        group.by = \"sample\",\n        pt.size = 0) +\n  geom_hline(yintercept = 500, color = \"red\") +\n  theme(legend.position = \"none\",\n        plot.margin = unit(c(0, 0, 0, 0), \"cm\"))\n\n# Plot genes detected per cell\nPnGene &lt;- VlnPlot(object = merged_seurat, \n        features = \"nGene\",\n        group.by = \"sample\",\n        pt.size = 0) +\n  geom_hline(yintercept = 250, color = \"red\") +\n  theme(legend.position = \"none\",\n        plot.margin = unit(c(0, 0, 0, 0), \"cm\"))\n\n# Plot complexity (novelty score)\nPlog10GpUMI &lt;- VlnPlot(object = merged_seurat, \n        features = \"log10GenesPerUMI\",\n        group.by = \"sample\",\n        pt.size = 0) +\n  geom_hline(yintercept = 0.8, color = \"red\") +\n  theme(legend.position = \"none\",\n        plot.margin = unit(c(0, 0, 0, 0), \"cm\"))\n\n# Plot percent mitochondrial UMI\nPpMito &lt;- VlnPlot(object = merged_seurat, \n        features = \"percMitoUMI\",\n        group.by = \"sample\",\n        pt.size = 0) +\n  geom_hline(yintercept = 20, color = \"red\") +\n  theme(legend.position = \"none\",\n        plot.margin = unit(c(0, 0, 0, 0), \"cm\"))\n\n# Combine plots\nplot_grid(PnUMI, PnGene, Plog10GpUMI, PpMito, ncol = 2)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#joint-filtering-effects","title":"Joint filtering effects","text":"<p>Two metrics that are often evaluated together are the number of UMIs and the number of genes detected per cell. Here, we have plotted the number of genes versus the number of UMIs coloured by the fraction of mitochondrial reads. Jointly visualizing the count and gene thresholds and additionally overlaying the mitochondrial fraction, gives a summarized perspective of the quality per cell.</p> <pre><code>merged_seurat@meta.data %&gt;% \n    ggplot(aes(x=nUMI, y=nGene, color=percMitoUMI)) + \n    geom_point() + \n    scale_colour_gradient(low = \"gray90\", high = \"black\") +\n    scale_x_log10() + \n    scale_y_log10() + \n    theme_classic() +\n    geom_vline(xintercept = 500, color = \"red\") +\n    geom_hline(yintercept = 250, color = \"red\") +\n    facet_wrap(~sample)\n</code></pre> <p></p> <p>Next, we can check the number of cells that pass each threshold.</p> <pre><code># nUMI\nTABnUMI &lt;- table(merged_seurat$nUMI &gt; 500)\n\n# nGene\nTABnGene &lt;- table(merged_seurat$nGene &gt; 250)\n\n# log10GenesPerUMI\nTABlog10GpUMI &lt;- table(merged_seurat$log10GenesPerUMI &gt; 0.8)\n\n# percMitoUMI\nTABpercMitoUMI &lt;- table(merged_seurat$percMitoUMI &gt; 0.2)\n\n# All filters\nTABall &lt;- table(merged_seurat$nUMI &gt; 500 &amp;\n                  merged_seurat$nGene &gt; 250 &amp;\n                  merged_seurat$log10GenesPerUMI &gt; 0.8 &amp;\n                  merged_seurat$percMitoUMI &gt; 0.2)\n\n# Compile results to a single data frame\nfilterDF &lt;- as.data.frame(rbind(TABnUMI, TABnGene, TABlog10GpUMI, TABpercMitoUMI, TABall))\nrownames(filterDF) &lt;- c(\"nUMI &gt; 500\", \n                        \"nGene &gt; 250\", \n                        \"log10GenesPerUMI &gt; 0.8\", \n                        \"percMitoUMI &gt; 0.2\", \n                        \"All filters\")\ncolnames(filterDF) &lt;- c(\"Fail\", \"Pass\")\n\nfilterDF\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#filter-cell-profiles-in-seurat-object","title":"Filter cell profiles in <code>Seurat</code> object","text":"<p>Finally, we can filter the cell profiles using the <code>subset()</code> <code>Seurat</code> function.</p> <pre><code>filtered_seurat &lt;- subset(merged_seurat, \n                          subset = nUMI &gt;= 500 &amp; \n                                   nGene &gt;= 250 &amp; \n                                   log10GenesPerUMI &gt; 0.80 &amp; \n                                   percMitoUMI &lt; 20)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#choosing-cell-profile-quality-control-thresholds","title":"Choosing cell profile quality control thresholds","text":"<p>Considering any of these QC metrics in isolation can lead to misinterpretation of cellular signals. For example, cells with a comparatively high fraction of mitochondrial counts may be involved in respiratory processes and may be cells that you would like to keep. Moreover, specific cell populations may be more affected by data collection and library preparation procedures, leading to inflated mitochondrial UMI content of these populations. A general rule of thumb when performing QC is to set thresholds for individual metrics to be as permissive as possible, and always consider the joint effects of these metrics. In this way, you reduce the risk of filtering out any viable cell populations. </p> <p>Accordingly, a common strategy is to go start with permissive filtering, and assess whether cell clusters are characterized by aberrant high or low values of quality control metrics in downstream analyses. Moreover, evaluate how whether these abberations track with a lack of clear marker genes or if they can be characterized solely based on the presence of mitochondrial markers.</p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#gene-level-filtering","title":"Gene-level filtering","text":"<p>Within our data we will have many genes with zero counts. These genes can dramatically reduce the average expression for a cell and so we will remove them from our data. If a gene is only expressed in a handful of cells, it is likely not meaningful to our downstream analysis. Moreover, it's important to keep in mind that as we move forward in our analyses, size of <code>Seurat</code> objects may become quite large, generally on the order of gigabytes, which present headaches in terms of available memory and run time. Thus removing inconsequential features from our data can make our lives easier.</p> <p>For our data we choose to keep only genes which are expressed in 10 or more cells.</p> <pre><code>## Extract count matrix from Seurat object\ncounts &lt;- GetAssayData(object = filtered_seurat, slot = \"counts\")\n\n## Convert the counts to a matrix of logicals\n## in which TRUE indicates counts &gt; 0\nnonzero &lt;- counts &gt; 0\n\n# Sums all TRUE values and returns TRUE if more than 10 TRUE values per gene\nkeep_genes &lt;- rowSums(nonzero) &gt;= 10\n\ntable(keep_genes)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#subset-filtered-seurat-object","title":"Subset filtered seurat object","text":"<pre><code>filtered_seurat &lt;- filtered_seurat[keep_genes,]\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/03_quality_control/#save-seurat-object","title":"Save seurat object","text":"<p>That's it! We now have a cell profile- and gene-wise QC'd <code>Seurat</code> object. In the following workshops we will move on to the procedures for yielding cluster estimates of our cell populations.</p> <pre><code>saveRDS(filtered_seurat, file.path(baseDir, \"results/merged_filtered_seurat.rds\"))\n</code></pre> <p>You can now open \"04_integration.Rmd\" to continue on the the next section.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/","title":"Single Cell RNA Sequencing Normalization, Dimensionality Reduction, and Integration","text":"<p>In this section we will describe procedures for processing scRNAseq data to facilitate downstream analysis, particularly clustering of scRNAseq profiles to identify cell populations. These procedures include</p> <ul> <li>Normalization</li> <li>Dimensionality Reduction</li> <li>Integration</li> </ul> <p>We will perform these procedures on our two-sample combined, formatted, and QC'd PBMC scRNAseq data set [<code>Seurat</code>] object generated in the previous sections. Portions of this section have been adapted from  previous Tufts HPC describing normalization and integration.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#setting-up-r-environment","title":"Setting up R environment","text":"<p>We begin by setting up our R environment similar to the previous sections.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#r-library-source","title":"R library source","text":"<p>We will be reading in and writing files relative to our <code>intro_to_scrnaseq</code>. For simplicity, we will create an R object that is simply a character string that gives this path, and use it as a prefix for reading and writing files.</p> <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#read-in-r-packages","title":"Read in R packages","text":"<p>For this section, requires three R packages:</p> <ol> <li><code>Seurat</code> : A package for working with and analysis of scRNAseq data. Comprehensive tutorials for available analyses with the <code>Seurat</code> R package are available on the project website.</li> <li><code>ggplot2</code>: The standard package for creating plots in R. Much of the plotting functions are wrappers for <code>ggplot2</code> functionality.</li> <li><code>cowplot</code> : A nice package for combining plots into a single figure. Specifically we will make use of of the <code>plot_grid()</code> function.</li> </ol> <pre><code>library(Seurat)\nlibrary(ggplot2)\nlibrary(cowplot)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#set-base-directory","title":"Set base directory","text":"<pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#read-in-seurat-object","title":"Read in <code>Seurat</code> object","text":"<pre><code>filtered_seurat &lt;- readRDS(file.path(baseDir, \"results/merged_filtered_seurat.rds\"))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#expression-normalization","title":"Expression normalization","text":"<p>Even for the same types of cells, the total number of UMIs that are counted is highly variable cell profile to cell profile. Accordingly, the UMI counts for each gene are not immediately comparable as they are proportional to the total number of reads. When performing data normalization we account for this variation by a dividing the reads from each cell by a scaling factor that is a function of the total number of reads of that cell.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#log-transformation","title":"Log-transformation","text":"<p>The variance of normalized counts are affected by their magnitude. By performing log-transformation, we partially account for this source of variance, making gene profiles more immediately comparable. </p> <p>Data normalization and log-transformation can be performed in a single step with the <code>Seurat</code> package with the <code>NormalizeData()</code> function. Below we will run this function and create a new <code>Seurat</code> object, <code>norm_seurat</code>.</p> <pre><code>norm_seurat &lt;- NormalizeData(filtered_seurat)\n</code></pre> <p>Following <code>NormalizeData()</code>, the <code>data</code> \"slot\" of our <code>RNA</code> assay is not populated by our normalized and log-transformed count data. We can visualize this using the <code>VlnPlot()</code> <code>Seurat</code> function, where we specify the source of gene expression data using the <code>slot</code> argument. Below we visualize CD63 expression.</p> <pre><code>## Plot CD63 counts\ngPlotCount &lt;- VlnPlot(object = norm_seurat, \n                      features = \"CD63\",\n                      group.by = \"sample\",\n                      assay = \"RNA\",\n                      slot = \"count\") +\n  ggtitle(\"CD63 Counts\",\n          subtitle = \"RNA Assay\")\n\n## Plot CD63 normalized Expression\ngPlotNorm &lt;- VlnPlot(object = norm_seurat, \n                      features = \"CD63\",\n                      group.by = \"sample\",\n                      assay = \"RNA\",\n                      slot = \"data\") +\n  ggtitle(\"CD63 Norm. Expression\",\n          subtitle = \"RNA Assay\")\n\n## Combine plots\nplot_grid(gPlotCount, gPlotNorm, nrow = 1)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#cleaning-up-r-environment","title":"Cleaning up R environment","text":"<p><code>Seurat</code> objects contain a lot of data and become quite memory expensive. Especially when working on machines with limited available memory, removing objects we are done with can save headaches down the line. We are done with <code>filtered_seurat</code> so we can now go ahead and remove it.</p> <pre><code>rm(filtered_seurat)\ngc()\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#dimensionality-reduction","title":"Dimensionality reduction","text":"<p>The purpose of dimensionality reduction to capture the majority of variability in our data with fewer features than the 1,000s of genes in our data. By doing so we emphasize sources of variability that are indicative of similar and diverging cell types in our data. We can then use these new variables as input in numerous machine learning algorithms, such many of those employed for cluster analysis. Specifically, through Principal Component Analysis (PCA), we can reduce our matrix of 1,000's to 10's of features (i.e. principal components) that capture the majority of variabilty in our data.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#feature-selection","title":"Feature selection","text":"<p>Our <code>Seurat</code> objects is currently comprised of 14,065 features. Prior to running PCA, we will first identify 2,000 genes with high variance in our data. The justification of this is that highly variable genes should capture differences in expression across cell populations. Moreover, is makes calculation of our principal components less computationally expensive. We can perform feature selection using the <code>FindVariableFeatures()</code> <code>Seurat</code> function.</p> <pre><code>norm_seurat &lt;- FindVariableFeatures(norm_seurat, \n                                     selection.method = \"vst\",\n                                     nfeatures = 3000, \n                                     verbose = FALSE)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#expression-scaling","title":"Expression scaling","text":"<p>PCA is highly affected by the scale of values in our data. Accordingly, appropriate application of PCA requires that expression values are scaled to mean = 0, and standard deviation = 1. We can perform this scaling using the <code>ScaleData()</code> <code>Seurat</code> function.</p> <p><pre><code>norm_seurat &lt;- ScaleData(norm_seurat)\n</code></pre> Following <code>ScaleData()</code>, the <code>scale.data</code> \"slot\" of our <code>RNA</code> assay is not populated. Below we visualize CD63 expression of all three of out expression data slots.</p> <p></p> <p>Now that we have our scaled data comprising 2,000 genes, we can perform PCA, using the <code>RunPCA()</code> <code>Seurat</code> function.</p> <pre><code>norm_seurat &lt;- RunPCA(norm_seurat)\n</code></pre> <p>Next, we can visualize our first two principal components using the <code>PCAPlot()</code> <code>Seurat</code> function. Additionally, we will color our points by samples, \"ctrl\" and \"stim\", to evaluate whether variability in our data reflects these differences.</p> <pre><code>pPlot &lt;- PCAPlot(norm_seurat, group.by = \"sample\") +\n  ggtitle(\"PCA\",\n          subtitle = \"RNA Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\npPlot\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#uniform-manifold-approximation","title":"Uniform manifold approximation","text":"<p>We just visualized the first two principal components in our data. However, it is more than likely that important variability in our data is captured by additional principal components. Uniform manifold approximation (UMAP) is a procedure for visualizing many variables in two dimensions. Importantly, UMAP should only be considered as a visualization tool, and our PCA matrix is what is leveraged in downstream clustering analyses. Next, we'll run UMAP with the <code>RunUMAP()</code> <code>Seurat</code> function, on the first 10 principal components using the <code>dims</code> argument.</p> <pre><code>norm_seurat &lt;- RunUMAP(norm_seurat, dims = seq(10))\n</code></pre> <p>Now we can visualize our UMAP output side-by-side with our first two principal components.</p> <pre><code>uPlot &lt;- UMAPPlot(norm_seurat, group.by = \"sample\") +\n  ggtitle(\"UMAP\",\n          subtitle = \"RNA Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\nplot_grid(pPlot, uPlot, nrow = 1)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#alternative-expression-normalization-and-scaling-with-sctransform","title":"Alternative expression normalization and scaling with <code>SCTransform()</code>","text":"<p>In the Hafemeister and Satija, 2019 paper the authors explored the issues with simple transformations. Specifically they evaluated the standard log normalization approach and found that genes with different abundances are affected differently and that effective normalization (using the log transform) is only observed with low/medium abundance genes (Figure 1D, below). Additionally, substantial imbalances in variance were observed with the log-normalized data (Figure 1E, below). In particular, cells with low total UMI counts exhibited disproportionately higher variance for high-abundance genes, dampening the variance contribution from other gene abundances.</p> <p></p> <p>The proposed solution was the use of Regularized Negative Binomial Regression, as implemented in the <code>Seurat</code> <code>SCTransform()</code> function. This approach</p> <ul> <li>Does not assume fixed number of UMI counts per cell</li> <li>Normalizes expression values based on their Pearson residuals from negative binomial regression of UMI counts of each gene against total UMI counts of each profile.</li> </ul> <p>In the next code chunk, we demonstrate usage of the <code>SCTransform()</code> function. DO NOT RUN THIS. <code>SCTransform()</code> is more computationally expensive and takes several minutes to run. Instead we will read in a a saved <code>norm_seurat</code> object, for which <code>SCTransform()</code> has been performed.</p> <pre><code>### DON'T RUN!!\nnorm_seurat &lt;- SCTransform(norm_seurat)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#read-in-sctransorm-seurat-object","title":"Read in <code>SCTransorm()</code> <code>Seurat</code> object","text":"<pre><code>norm_seurat &lt;- readRDS(file.path(baseDir, \"data/normalized_seurat.rds\"))\n</code></pre> <p>Rather than replacing the data in our <code>RNA</code> assay, <code>SCTransform()</code> creates a new assay <code>SCT</code>, and sets it as the default assay. This new assay contains fully populated count, normalized, and scaled data, in the <code>count</code>, <code>data</code>, and <code>scale.data</code> slots, respectively. </p> <pre><code>norm_seurat\n</code></pre> <p></p> <pre><code>DefaultAssay(norm_seurat)\n</code></pre> <p></p> <p>Importantly, <code>Seurat</code> functions will generally use the active (i.e. default) assay unless otherwise specified. Since <code>SCT</code> is now our e can re-run our PCA and UMAP on the <code>SCTransform()</code> scaled data using the same commands. Importantly, this will overwrite these matrices in our <code>Seurat</code> object because these are stored separately from assays. </p> <pre><code>## Run PCA on SCT assay\nnorm_seurat &lt;- RunPCA(norm_seurat)\n\n## Run UMAP on first 10 PCs from updated PCA matrix\nnorm_seurat &lt;- RunUMAP(norm_seurat, dims = seq(10))\n</code></pre> <p>Next, we will visualize our PCA and UMAP results calculated from our <code>SCT</code> assay side-by-side with those calculated from our <code>RNA</code> assay.</p> <pre><code>## Plot SCT PCA results\npPlotSCT &lt;- PCAPlot(norm_seurat, group.by = \"sample\") +\n  ggtitle(\"PCA\",\n          subtitle = \"SCT Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n## Plot SCT UMAP results\nuPlotSCT &lt;- UMAPPlot(norm_seurat, group.by = \"sample\") +\n  ggtitle(\"UMAP\",\n          subtitle = \"SCT Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n# Combine Plots\nplot_grid(pPlot, pPlotSCT, \n          uPlot, uPlotSCT, nrow = 2)\n</code></pre> <p></p> <p>Regardless of our normalization approach, it is clear that much of the variability in our data arise from differences between the data sets. This may arise from various sources. For one, our two samples represent two different conditions, i.e. control and interferon beta-treatment. Alternatively, these difference can arise from numerous technical factors during sample collection and library preparation, akin to \"batch\" effects, which are common in RNAseq experiments. </p> <p>Importantly, we expect to find most if not all of the same cell types represented these samples/conditions, and we will seek to characterize these cell types via clustering analysis. Thus, we'd like cells of the same type to cluster together in order to make these results more interpretable and cell types easier to characterize. </p> <p>Next, we will perform data integration to \"harmonize\" the expression profiles across these samples with the goal of overlaying transcriptomic profiles of shared cell types.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#data-integration","title":"Data Integration","text":"<p>The data integration workflow from the <code>Seurat</code> package is carried out in four main steps</p> <ol> <li>Identification of shared highly variable genes across data sets, performed by the <code>SelectIntegrationFeatures()</code>.</li> <li>Ensure that each data set has been normalized and scaled based on these features, performed by <code>PrepSCTIntegration()</code>.</li> <li>Scores the relative similarity of individual cells across data sets, performed by <code>FindIntegrationAnchors()</code>. This is actually performed in two sub-steps:</li> <li>Canonical Correlation Analysis (CCA)</li> <li>Mutual Nearest Neighbors (MMN)</li> <li>Projects the expression profiles of individual cells to be more similar to their counterparts across data sets, performed by <code>IntegrateData()</code>.</li> </ol>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#canonical-correlation-analysis-cca","title":"Canonical Correlation Analysis (CCA)","text":"<p>The implementation of CCA in <code>Seurat</code> is effectively very similar to PCA. Whereas with PCA we seek to capture the majority of variability in a single data set in in a few features, with CCA we seek to capture the majority of \"shared\" variability between data sets in fewer features. Thus after implementing CCA we should obtain a set of features with reduced sample-specific variability that should capture shared signal of cell types represented across samples.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#mutual-nearest-neighbors-mnn","title":"Mutual Nearest Neighbors (MNN)","text":"<p>MNN comprises two main steps. First, for each profile we identify its \"K\" most similar cell profiles (\"nearest neighbors\") in the other data set based on their CCA features. Second, \"Mutual nearest neighbors\" are instances in which pairs of inter-data set cell profiles are complementary identified as nearest neighbors of one another. When we perform integration, the expression of each cell profile in one data set will be projected to be more similar to its MNN counterparts in the other data set.</p> <p>We begin by splitting our <code>Seurat</code> object into a <code>list</code> object of two <code>Seurat</code> objects for each sample, \"ctrl\" and \"stim\", with the <code>SplitObject()</code> <code>Seurat</code> function.</p> <pre><code>split_seurat &lt;- SplitObject(norm_seurat, split.by = \"sample\")\n\nsplit_seurat\n</code></pre> <p></p> <p>At this point we will not be doing anything with our <code>norm_seurat</code> object. So let's remove it to save space.</p> <pre><code>rm(norm_seurat)\ngc()\n</code></pre> <p>**Sadly, at this point the following integration steps are quite memory expensive and slow. For this reason we give an example of how to run the integration workflow, but we will skip running the code. Instead will read in a previously integrated <code>Seurat</code> object generated by these steps.</p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#select-integration-features","title":"Select integration features","text":"<pre><code>## DON'T RUN!\ninteg_features &lt;- SelectIntegrationFeatures(object.list = split_seurat, \n                                            nfeatures = 3000) \n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#prepare-the-sct-list-object-for-integration","title":"Prepare the SCT list object for integration","text":"<pre><code>## DON'T RUN!\nsplit_seurat &lt;- PrepSCTIntegration(object.list = split_seurat, \n                                   anchor.features = integ_features)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#perform-cca-and-identify-mutual-nearest-neighbots","title":"Perform CCA and identify mutual nearest neighbots","text":"<pre><code>## DON'T RUN!\ninteg_anchors &lt;- FindIntegrationAnchors(object.list = split_seurat, \n                                        normalization.method = \"SCT\", \n                                        anchor.features = integ_features)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#integrate-data","title":"Integrate data","text":"<pre><code>## DON'T RUN!\ninteg_seurat &lt;- IntegrateData(anchorset = integ_anchors, \n                                   normalization.method = \"SCT\")\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#read-in-integrated-seurat-object","title":"Read in integrated <code>Seurat</code> object","text":"<pre><code>integ_seurat &lt;- readRDS(file.path(baseDir, \"data/integrated_seurat.rds\"))\n</code></pre> <p>Similarly to when we ran <code>SCTransform()</code>, the integration workflow results in new assay in our <code>Seurat</code> object, <code>integrated</code> and set it as the active (default) assay.</p> <pre><code>integ_seurat\n</code></pre> <p></p> <pre><code>DefaultAssay(integ_seurat)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/04_integration/#check-integrated-data-set","title":"Check integrated data set","text":"<p>Now that we have performed the integration procedure, we can interrogate our <code>integrated</code> assay for differences between samples using dimensionality reduction.</p> <p>As before we'll re-run PCA, followed by re-running UMAP on the first 10 principal components.</p> <pre><code>## Run PCA on integrated assay\ninteg_seurat &lt;- RunPCA(integ_seurat)\n\n## Run UMAP on first 10 PCs from updated PCA matrix\ninteg_seurat &lt;- RunUMAP(integ_seurat, dims = seq(10))\n</code></pre> <p>Finally, we will visualize our PCA and UMAP results calculated from our <code>integrated</code> assay side-by-side with those calculated from the <code>SCT</code> assay of the un-integrated data.</p> <pre><code>## Plot integrated PCA results\npPlotInt &lt;- PCAPlot(integ_seurat, group.by = \"sample\") +\n  ggtitle(\"PCA\",\n          subtitle = \"Integrated Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n## Plot integrated UMAP results\nuPlotInt &lt;- UMAPPlot(integ_seurat, group.by = \"sample\") +\n  ggtitle(\"UMAP\",\n          subtitle = \"Integrated Assay\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n# Combine Plots\nplot_grid(pPlotSCT, pPlotInt, \n          uPlotSCT, uPlotInt, nrow = 2)\n</code></pre> <p></p> <p>That's it! Now, we have a fully processed and integrated data set. In the next section we will go over procedures for clustering scRNAseq to facilitate cell population identification.</p> <p>You can now open \"05_clustering.Rmd\" to continue on the the next section.</p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/","title":"Single Cell RNA Sequencing Clustering","text":"<p>In this section we will describe procedures for clustering scRNAseq.</p> <p>We will perform these procedures on our two-sample combined, formatted, QC'd, and integrated PBMC scRNAseq data set [<code>Seurat</code>] object generated in the previous sections. Portions of this section have been adapted from previous Tufts HPC workshops describing clustering and clustering quality control.</p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#setting-up-r-environment","title":"Setting up R environment","text":"<p>We begin by setting up our R environment similar to the previous sections.</p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#r-library-source","title":"R library source","text":"<p>We will be reading in and writing files relative to our <code>intro_to_scrnaseq</code>. For simplicity, we will create an R object that is simply a character string that gives this path, and use it as a prefix for reading and writing files.</p> <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#read-in-r-packages","title":"Read in R packages","text":"<p>For this section, requires three R packages:</p> <ol> <li><code>Seurat</code> : A package for working with and analysis of scRNAseq data. Comprehensive tutorials for available analyses with the <code>Seurat</code> R package are available on the project website.</li> <li><code>ggplot2</code>: The standard package for creating plots in R. Much of the plotting functions are wrappers for <code>ggplot2</code> functionality.</li> <li><code>cowplot</code> : A nice package for combining plots into a single figure. Specifically we will make use of of the <code>plot_grid()</code> function.</li> </ol> <pre><code>library(Seurat)\nlibrary(ggplot2)\nlibrary(cowplot)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#set-base-directory","title":"Set base directory","text":"<pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#read-in-integrated-seurat-object","title":"Read in integrated <code>Seurat</code> object","text":"<pre><code>integ_seurat &lt;- readRDS(file.path(baseDir, \"data/integrated_seurat.rds\"))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#data-clustering","title":"Data Clustering","text":"<p>The data clustering workflow from the <code>Seurat</code> package is carried out in three main steps</p> <ol> <li>Principal component analysis, performed by <code>RunPCA()</code>.</li> <li>K-nearest neighbor analysis, performed by <code>FindNeighbors()</code>.</li> <li>Cluster estimation, performed by <code>FindClusters()</code></li> </ol>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#principal-component-analysis","title":"Principal Component Analysis","text":"<p>We've already performed PCA a number of times. We'll run it just one more time to illustrate the steps in the workflow. Moreover, we'll demonstrate a strategy for choosing important PCs to be used in cluster analysis.</p> <pre><code>integ_seurat &lt;- RunPCA(integ_seurat)\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#choosing-the-number-of-principal-components-for-clustering","title":"Choosing the number of principal components for clustering","text":"<p>Clustering analysis can feel like an analytically \"squishy\" process. There are many \"knobs\" we can turn in terms of parameters we can set that can affect our clustering output, and consequent downstream analysis. One such knob is the choice of PCs to use as input in our clustering procedure. If we choose to few PCs we risk failing to include biologically relevant information in our data. If we choose too many PCs we risk including spurious variability in our data. Optimizing this process is a difficult task and we generally rely on heuristics for choosing our parameters.</p> <p>One such heuristic is plot the relationship between PC ranking and their respective standard deviation, where the standard deviation gives us a sense of the amount of variability each PC captures in our data. The general strategy is to use this \"elbow plot\", to make a decision about at what PC our standard deviation level out at subsequent PCs.</p> <p>We can create this plot using the <code>ElbowPlot()</code> <code>Seurat</code> function.</p> <pre><code>ElbowPlot(integ_seurat, ndims = 50)\n</code></pre> <p></p> <p>A \"squishy\" part here, is where we decide the \"elbow\" is. Clearly, there is a leveling out after the first 7 PCs. However, we also see a drop after the 17th PC. Generally, it is advisable to err on the side of more PCs, as choosing too few PCs we run the risk of lacking the resolution to identify rare cell types. Accordingly, we'll move on with 17 as our choice of PC dimension.</p> <p>Next, we'll use a run UMAP to make an initial assessment as to whether our samples appear well integrated at 17 PCs.</p> <pre><code>integ_seurat &lt;- RunUMAP(integ_seurat, dims = seq(17))\n</code></pre> <pre><code>uPlot_dim17 &lt;- UMAPPlot(integ_seurat, group.by = \"sample\") +\n  ggtitle(\"UMAP\",\n          subtitle = \"# PCs = 17\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\nuPlot_dim17\n</code></pre> <p></p> <p>It appears that at 17 PCs our data relatively homogeneous in terms of the mixture of cell profiles in lower dimension, so we'll move on to clustering.</p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#determine-the-k-nearest-neighbor-graph","title":"Determine the K-nearest neighbor graph","text":"<p>The <code>Seurat</code> clustering workflow is a \"graph\" based method, which means that it takes as input a graph in which nodes are individual cell profiles and edges are connections between cell profiles, based on some similarity measure. Thus, before clustering we will construct a K-nearest neighbor graph (KNN). \"Near\" refers to the similarity of cell profiles in our reduced 17 dimension data set. \"K\" refers to the number of the \"nearest\" neighbors to choose for each cell profile.</p> <p>In <code>Seurat</code>, KNN is performed using the <code>FindNeighbors()</code> function. If you look at the documentation you will see that there are many different parameters you can set for this process. For example, K is set to 20, with the argument <code>k.param</code>. In practice, researchers generally leave the defaults alone, so we won't get into the weeds about optimizing this step.</p> <pre><code>integ_seurat &lt;- FindNeighbors(object = integ_seurat, \n                                   dims = seq(17))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#perform-clustering-with-the-louvain-algorithm","title":"Perform clustering with the Louvain algorithm","text":"<p>By default, <code>Seurat</code> performs clustering on the KNN graph, using the Louvain algorithm. The Louvain algorithm works by recursively merging the most similar cell profiles in clusters, based on an optimization metric, called \"modularity\". The algorithm will stop after a certain modularity value has been reached, yielding the final cluster estimates. </p> <p>In <code>Seurat</code> the Louvain algorithm is performed by the <code>FindClusters()</code> function. Again, there are knobs we can turn in this process, particularly the <code>resolution</code> parameter, which controls the stopping value. This is set to 0.8, by default, and lower values will result in earlier stoppage, i.e. fewer clusters, and the opposition for higher values. here, we can take a heuristical approach by clustering under several resolution parameters, and then view our results in lower dimension with UMAP. Again, this is a \"squishy\" process, and prior knowledge about the general types of cells we expect in our data is very helpful.</p> <p>Here we will run <code>FindClusters()</code> with three levels of resolution by setting <code>resolution = c(0.4, 0.8, 1.4)</code>. This will create three new columns in our metadata, \"integrated_snn_res.0.4\", \"integrated_snn_res.0.8\", \"integrated_snn_res.1.4\", each will the cluster assignments under each parameter.</p> <pre><code>integ_seurat &lt;- FindClusters(object = integ_seurat,\n                                  resolution = c(0.4, 0.8, 1.4))\n</code></pre> <p>Next, we plot the UMAPs, color and labeling the cell profiles each different resolution.</p> <pre><code>uPlotCl0p4 &lt;- UMAPPlot(integ_seurat, group.by = \"integrated_snn_res.0.4\", label = TRUE) +\n  ggtitle(\"UMAP\", \n          subtitle = \"Res. = 0.4, # PCs = 17\") +\n  theme(\n    legend.position = \"none\"\n  )\n\nuPlotCl0p8 &lt;- UMAPPlot(integ_seurat, group.by = \"integrated_snn_res.0.8\", label = TRUE) +\n  ggtitle(\"UMAP\", \n          subtitle = \"Res. = 0.8, # PCs = 17\") +\n  theme(\n    legend.position = \"none\"\n  )\n\nuPlotCl1p4 &lt;- UMAPPlot(integ_seurat, group.by = \"integrated_snn_res.1.4\", label = TRUE) +\n  ggtitle(\"UMAP\", \n          subtitle = \"Res. = 1.4, # PCs = 17\") +\n  theme(\n    legend.position = \"none\"\n  )\n\nplot_grid(uPlotCl0p4, uPlotCl0p8, uPlotCl1p4, nrow = 1)\n</code></pre> <p></p> <p>Here, we can see that at resolution = 0.4. We appear to capture clusters of cell profiles that appear to be most similar in terms of their \"bunching\". At higher resolutions, the data appears like it might be \"over clustered\", i.e. some of the cluster assignments appear arbitrary.</p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#inspecting-cluster-results","title":"Inspecting cluster results","text":""},{"location":"intro_to_single_cell_rnaseq/05_clustering/#visualize-distributions-of-qc-variables-in-clusters","title":"Visualize distributions of QC variables in clusters","text":"<p>Following clustering it's good practice to inspect the distribution of different quality control variables across each of our clusters, as they can indicate instances in which clusters formed from non-biologically informative variability in our data. For example, we could find specific clusters characterized by generally high mitochondrial content, indicating that these may be of \"low-quality\" dying cells induced by sample preparation. Moreover, clusters with anomalously high counted genes could indicate the presence of \"doublets\", which are instances of multiple cells sequenced as a single profile.</p> <p>We do this below using the <code>VlnPlot()</code> <code>Seurat</code> function.</p> <pre><code>VlnPlot(integ_seurat, \n        group.by = \"integrated_snn_res.0.4\", \n        features = c(\"nUMI\", \"nGene\", \"log10GenesPerUMI\", \"percMitoUMI\"), \n        ncol = 1)\n</code></pre> <p></p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#check-cell-cluster-assignments-accross-samples","title":"Check cell cluster assignments accross samples","text":"<p>Finally, we'll check the distribution of profiles originating from each sample in our clusters. This will inform whether our cluster assignments generally represented between samples, and whether specific clusters appear over-represented by either sample. If the former is false, we can generally assume that our integration procedure was ineffective at capturing shared sources of variability across data sets. However, if we observe a few specific cell clusters that are specific to a single sample, it could be due to such a technical artifact or biologically meaningful differences in abundance of specific cell populations between samples.</p> <p><pre><code>table(integ_seurat[[c(\"integrated_snn_res.0.4\", \"sample\")]])\n</code></pre> </p> <p><pre><code>prop.table(table(integ_seurat[[c(\"integrated_snn_res.0.4\", \"sample\")]]), margin = 2)\n</code></pre> </p>"},{"location":"intro_to_single_cell_rnaseq/05_clustering/#save-seurat-object","title":"Save seurat object","text":"<p>That's it! We not have our fully clustered <code>Seurat</code> object. We'll go ahead and save it for the next workshop, which will cover cell type identification and differential expression analyses.</p> <pre><code>saveRDS(integ_seurat, file.path(baseDir, \"results/clustered_seurat.rds\"))\n</code></pre>"},{"location":"intro_to_single_cell_rnaseq/06_cell_type_identification/","title":"Cell-type Identification","text":"<p>In this section, we'll demonstrate two automated methods to label cells in our dataset using reference datasets with known cell labels. More information on these methods is presented in Lecture Part II.</p> <ul> <li>SingleR method, which uses correlation of gene expression. This method can use both single-cell and bulk RNAseq reference datasets. </li> <li>Seurat Integration Mapping which applies integration between a labeled, reference single-cell RNAseq dataset and our query dataset</li> </ul> <p>To start, we set our library path on the HPC cluster: <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre></p> <p>We require three new packages: - Singler - celldex: A collection of reference expression datasets with cell type labels  - pheatmap A package to make \"pretty\" heatmaps.</p> <pre><code>suppressPackageStartupMessages({\n  library(Seurat)\n  library(tidyverse)\n  library(cowplot)\n  library(SingleR)\n  library(celldex)\n  library(pheatmap)\n})\n</code></pre> <p>Set the base dir: <pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre></p> <p>We begin by loading a pre-processed version of our integrated, clustered samples from the <code>data</code> folder. <pre><code>integ_seurat = readRDS(file.path(baseDir, \"data/clustered_seurat.rds\"))\n</code></pre></p> <p>When we left off, we had integrated our unstimulated (<code>ctrl</code>) and interferon beta stimulated (<code>stim</code>) PBMC samples and clustered the resulting dataset at resolution 0.4. We can visualize the cells both using either cluster or sample labels: <pre><code>Idents(object = integ_seurat) &lt;- \"integrated_snn_res.0.4\"\np1 &lt;- DimPlot(integ_seurat, label=T)\n\nIdents(object = integ_seurat) &lt;- \"sample\"\np2 &lt;- DimPlot(integ_seurat)\n\nplot_grid(p1, p2)\n</code></pre> </p>"},{"location":"intro_to_single_cell_rnaseq/06_cell_type_identification/#singler-correlation-method","title":"SingleR Correlation Method","text":"<p>First, we'll use SingleR along with a reference database of expression profiles of known cell types in order to identify our cells and clusters. As mentioned in the lecture, this method measures the correlation of overall gene expression between cells in a reference database with cells in the query dataset in order to label cells.</p> <p>To start, we'll use a database of bulk RNAseq profiles of Human pure cell-types called the Human Primary Cell Type Atlas.  This dataset along with several others is available through the celldex R library. A database like this is useful as a starting point to determine which broad cell types your sample has, either because there is no existing single-cell reference for your sample-type, or because you want to make sure that your sample-type contains the expected cell types before using a more specific single-cell reference. </p> <p>To load, type the following, and type <code>yes</code> when prompted to create the <code>ExperimentHub</code> directory in a hidden <code>.cache</code> directory in your home folder. <pre><code>hpca = HumanPrimaryCellAtlasData()\n</code></pre> The HPCA object has a data type called <code>Summarized Experiment</code> which allows one to store numeric data matrices in <code>assays</code> along with a data.frame providing annotation columns for sample in the data. </p> <p></p> <p>We can access the sample annotations in the <code>@colData</code> slot, which show the sample cell-types. We can access the log-transformed expression data in the <code>@assay</code> slot. <pre><code>head(hpca@colData)\nhead(hpca@assays@data$logcounts)\n</code></pre></p> <p>Well use the coarse-grained cell-type labels, <code>label.main</code>, column of the metadata, which has the following cell-types: <pre><code>unique(hpca$label.main)\n</code></pre> </p> <p>The data to be labeled is input into SingleR as a log-transformed, normalized count matrix, which we can extract from the <code>RNA</code> assay our <code>integ_seurat</code> object: <pre><code>query_counts = integ_seurat@assays$RNA@data\n</code></pre></p> <p><code>SingleR</code> can be run both on the cluster level and the individual cell level. For cluster-level annotation, the average expression profile of each cluster is used and a single label is generated. This is much faster to run, since we have many fewer clusters than cells, so we'll start here.</p> <pre><code>query_clusters = integ_seurat@meta.data$integrated_snn_res.0.4\n</code></pre> <p>The following command runs SingleR on the cluster level, without pruning, which should take only a few seconds. <pre><code>pred_cluster &lt;- SingleR(test = query_counts,\n                        clusters = query_clusters,\n                        ref = hpca,\n                        labels = hpca$label.main, \n                        prune=F)\n</code></pre></p> <p>Save the results: <pre><code>saveRDS(pred_cluster, file.path(baseDir, \"results/singler_hpca_cluster_res0.4.rds\"))\n</code></pre></p> <p>We can view the results, which contain a score for every cell type plus the final label: <pre><code>view(pred_cluster)\n</code></pre></p> <p>Select the columns that start with <code>score</code> to plot as a heatmap and the <code>label</code> column to annotate the heatmap: <pre><code>scores = data.frame(pred_cluster) %&gt;%\n  dplyr::select(starts_with(\"scores\")) \n\nlabels = data.frame(pred_cluster) %&gt;%\n  dplyr::select(\"labels\")\n</code></pre></p> <p>The scores and chosen labels can be plotted using <code>pheatmap</code>: <pre><code>pheatmap(scores,\n         annotation_row = labels) \n</code></pre> </p> <p>Four cell-types were found in our data: B_cell, Monocyte, NK_cell and T_cell. However, some clusters like 10, 11, 12, do not appear to have a good match for any reference cell type.  </p> <p>Let's add the labels make a named list with new names: <pre><code>new_names = pred_cluster$labels\nnames(new_names) = rownames(pred_cluster)\nnew_names\n</code></pre> </p> <p>Set the identities to the clusters found at resolution 0.4, rename the identities, and add the names to the Seurat metadata: <pre><code>Idents(object = integ_seurat) &lt;- \"integrated_snn_res.0.4\"\ninteg_seurat = RenameIdents(integ_seurat, \n                                 new_names)\ninteg_seurat$singler_cluster_labels = Idents(integ_seurat)\n</code></pre></p> <p>Plot the labeled clusters: <pre><code>Idents(integ_seurat) = \"singler_cluster_labels\"\nDimPlot(integ_seurat, \n        label=T)\n</code></pre> </p> <p>Running <code>SingleR</code> on the cell level uses the same method but eliminates the <code>clusters</code> argument from the command and enables the default pruning process. It will take ~20 minutes to run, so we'll run it as a batch job and not interactively (do not run the below code in Rstudio).</p> <p><pre><code># DON'T RUN!\npred_cell &lt;- SingleR(test = query_counts,\n                      ref = hpca,\n                      assay.type.test=\"logcounts\",\n                      labels = hpca$label.main)\n</code></pre> Running R scripts as batch job is convenient and does not require the Rstudio session to remain connected while the job runs. To navigate to our scripts directory and open <code>06_singler_cell.R</code>. This file contains the key steps above but runs <code>SingleR</code> on the cell level.</p> <p>To run it, we use an <code>SBATCH</code> file that is interpreted by the cluster job scheduler called slurm. Open the file <code>06_run_singler_cell.sh</code> in the <code>scripts</code> directory. </p> <p>The file contains a header which specifies the resources that the job will need so that an appropriate compute node can be allocated. Header lines start with <code>#SBATCH</code>. The body of the script specifies the code to be run once the job is started on a compute node. </p> <pre><code>#!/bin/bash                       # Use the bash shell interpreter\n#SBATCH -J run_singler            # Give the job a name\n#SBATCH --time=2:00:00            # Request 2 hours\n#SBATCH -n 1                      # Request 1 core\n#SBATCH -N 1                      # Request 1 node\n#SBATCH --mem=10Gb                # Request 10 Gb\n#SBATCH --output=%j.out           # Write the job output to a file prefixed by the job number\n#SBATCH --error=%j.err            # Write the job error to a file prefixed by the job number\n\nmodule purge                      # Remove loaded modules\nmodule load R/4.0.0               # Load R module\n\nRscript --no-save 06_singler_cell.R  # Run the script \n</code></pre> <p>To run the script: - Click on <code>Terminal</code> next to <code>Console</code> in the bottom portion of the <code>Rstudio</code> application - Change to our <code>scripts</code> directory by typing <code>cd ~/intro_to_scrnaseq/scripts</code> - Type <code>sbatch 06_run_singler_cell.sh</code> and press enter.  - Your job will be given a number by <code>slurm</code> and placed in the queue. - To check the status of your job, type <code>squeue -u tufts-username</code> and you will see your job status. </p> Is your job submitted successfully? <ul> <li>Yes (put up a green check mark in zoom)</li> <li>No (raise hand in zoom)</li> </ul> <p>In the meantime, let's load the pre-processed cell-level labels. <pre><code>pred_cell = readRDS(file.path(baseDir,\"data/singler_hpca_cell.rds\"))\nhead(pred_cell)\n</code></pre> </p> <p>The cell-level labels have one row for every cell. The table contains scores for each reference label as well as both a <code>labels</code> and a <code>pruned.labels</code> column. We can directly add the <code>pruned.labels</code> to the Seurat object metadata using the <code>AddMetaData</code> function. </p> <pre><code>integ_seurat  = AddMetaData(integ_seurat,\n                                 pred_cell$pruned.labels,\n                                 col.name = \"singler_cell_labels\")\n</code></pre> <p>Assign the idents and make a plot: <pre><code>Idents(integ_seurat) = \"singler_cell_labels\"\nDimPlot(integ_seurat, \n        label=T)\n</code></pre> </p> <p>Some clusters contain a mix of cell labels. We can view the breakdown of cell-type labels per cluster using pheatmap: <pre><code>tab &lt;- table(cluster=integ_seurat$integrated_snn_res.0.4,\n             label=pred_cell$labels)\n\n# divide by the total number of cells in each cluster\ntab &lt;- tab/rowSums(tab)\n\npheatmap(tab) \n</code></pre> </p> Are the dominant cell-level labels the same as the cluster-level labels? <ul> <li>Add a row annotation of the cluster-level labels in order to compare visually</li> </ul> <p>Some clusters appear to have a mix of cells, which may indicate that they contain a type of cell not in our reference database. This is expected since we've used a very general database. Next we'll use a single-cell RNAseq dataset that we expect will have a better match to our data.</p>"},{"location":"intro_to_single_cell_rnaseq/06_cell_type_identification/#seurat-integration-mapping","title":"Seurat Integration Mapping","text":"<p>The next reference dataset is a PBMC dataset available from 10X Genomics which has been pre-processed through the Seurat pipeline. Load the data: <pre><code>pbmc = readRDS(file.path(baseDir, \"data/pbmc_reference.rds\"))\n</code></pre></p> <p>The cell-type label is in the <code>seurat_annotation</code> metadata column. Set the cell identities to this column and plot: <pre><code>Idents(pbmc) = \"seurat_annotations\"\nDimPlot(pbmc, label=T)\n</code></pre></p> <p></p> <p>We see there are more specific T-cell and Monocyte cell subset labels. </p> <p>The first step is to find the transfer anchors using the function <code>FindTransferAnchors</code> with the following code. This step similar to the <code>FindIntegrationAnchors</code> function in the integration step, except the PCA is performed only on the reference dataset and the query dataset is projected onto the reference learned PCA structure (<code>reduction = \"pcaproject\"</code> and <code>project.query = FALSE</code> by default). This allows us to potentially use a reference dataset with many more cell types than our query dataset. </p> <pre><code>anchors &lt;- FindTransferAnchors(reference = pbmc, \n                                   query = integ_seurat)\n</code></pre> <p>Next, we'll transfer the reference cell-type labels to the query using <code>TransferData</code>. This step uses the proximity of each query cells to each anchors in order to label query cells. <pre><code>predictions&lt;- TransferData(anchorset = anchors, \n                                refdata = pbmc$seurat_annotations)\n</code></pre></p> <p>Add the predicted id to the metadata: <pre><code>integ_seurat &lt;- AddMetaData(integ_seurat, \n                                 metadata = predictions$predicted.id,\n                                 col.name = \"seurat_labels\")\n</code></pre></p> <p>Set the identities to our newly added column and plot: <pre><code>Idents(integ_seurat) = \"seurat_labels\"\nDimPlot(integ_seurat, \n            label=T )\n</code></pre></p> <p></p> <p>We can view the breakdown per cluster as a heatmap: <pre><code>tab &lt;- table(cluster=integ_seurat$integrated_snn_res.0.4,\n             label=integ_seurat$seurat_labels)\n\n# divide by the total number of cells in each cluster\ntab &lt;- tab/rowSums(tab)\n\npheatmap(tab) \n</code></pre></p> <p></p> <p>Cluster 11 cells are labeled predominantly Dendritic Cells. </p> <p>Finally, we save the labeled object: <pre><code>saveRDS(integ_seurat, file.path(baseDir,\"results/labeled_seurat.rds\"))\n</code></pre></p> <p>In the next section we'll look at a type of Differentially Expressed Gene known as a Marker Gene, which can help to confirm cell-type labels by confirming expression of known cell-type specific genes.</p>"},{"location":"intro_to_single_cell_rnaseq/07_differential_expression/","title":"Differential Expression","text":"<p>In this section we will identify differentially expressed genes. This a complementary method to understanding the biological meaning of our clusters.</p> <p>Differential Expression in scRNAseq has multiple meanings. Here we focus on two types: - Genes that are overexpressed in on cell-type compared to all other cell-types, known as \"Marker Genes\" - Genes that are statistically different between groups of cells with different phenotypes or conditions, known as \"Differentially Expressed Genes\"</p> <p>To start, we set our library path: <pre><code>LIB='/cluster/tufts/hpc/tools/R/4.0.0/'\n.libPaths(c(\"\",LIB))\n</code></pre></p> <p>We load our packages:</p> <pre><code>suppressPackageStartupMessages({\n  library(tidyverse)\n  library(cowplot)\n  library(Seurat)\n})\n</code></pre> <p>Set the base dir: <pre><code>baseDir &lt;- \"~/intro_to_scrnaseq/\"\n</code></pre></p> <p>We begin by loading the integrated, clustered, and labeled cells from <code>results</code>, created in the last section. One may alternatively load the integrated, clustered object from <code>data</code>.</p> <pre><code>integ_seurat = readRDS(file.path(baseDir, \"results/labeled_seurat.rds\"))\n</code></pre> <p>We again set identities to be the clusters found at the resolution 0.4 and set our default assay to be <code>RNA</code>: <pre><code>Idents(object = integ_seurat) &lt;- \"integrated_snn_res.0.4\"\nDefaultAssay(integ_seurat) = \"RNA\"\n</code></pre></p> <p>Next, use a <code>DotPlot</code> to visualize expression of genes <code>CD8A</code> and <code>PYURF</code>.  <pre><code>DotPlot(integ_seurat, \n         features = c(\"CD8A\",\"PYURF\"))\n</code></pre> </p> <p><code>DotPlot</code> is a useful as it allows us to visualize both percent of cells in a cluster that express a gene ( above 0 expression), as well as the average expression of the gene in a cluster. Notice that <code>CD8A</code> is more highly expressed in cluster 6 compared with other clusters and is therefore likely to be a marker gene for cluster 6. <code>PYURF</code> expression, on the other hand, is not cluster-specific. </p> <p>Next, examine the expression of these two genes in our two conditions using <code>VlnPlot</code>.</p> <p><pre><code>vln1 &lt;- VlnPlot(integ_seurat, \n        features = \"CD8A\",\n        split.by = \"sample\",\n        split.plot = TRUE, \n        pt.size = 0)\n\nvln2 &lt;- VlnPlot(integ_seurat, \n        features = \"PYURF\",\n        split.by = \"sample\",\n        split.plot = TRUE, \n        pt.size = 0)\n\nplot_grid(vln1, vln2, ncol = 2)\n</code></pre> </p> <p><code>VlnPlot</code> gives more detail about the distribution of expression levels and can be useful for comparing conditions. On the left we see that <code>CD8A</code> it is equally overexpressed in cluster 6 cells in the <code>ctr</code> and <code>stim</code> samples, while on the right we see that <code>PYURF</code> on the other hand seems to have condition-specific expression in several clusters, including cluster 6, and is likely differentially expressed by condition.</p>"},{"location":"intro_to_single_cell_rnaseq/07_differential_expression/#marker-genes","title":"Marker Genes","text":"<p>We will use <code>FindConservedMarkers</code> to find the markers of cluster 6 that are overexpressed in both conditions compared to all other clusters.</p> <pre><code>markers_6 = FindConservedMarkers(integ_seurat,\n                                         ident.1 = 6,\n                                         grouping.var = \"sample\",\n                                         only.pos = TRUE)\n</code></pre> <p>Some additional parameters that we use the defaults are: - <code>test.use</code> = \"wilcox\" - <code>logfc.threshold</code> = 0.25</p> <p>Run the code, and note the process <code>FindMarkers</code> is run separately on groups <code>ctrl</code> and <code>stim</code>: <pre><code>Testing group stim: (6) vs (3, 11, 1, 8, 0, 2, 4, 5, 10, 7, 9, 12)\n  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=11s  \nTesting group ctrl: (6) vs (1, 0, 4, 11, 2, 3, 12, 5, 8, 10, 7, 9)\n  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=09s  \n</code></pre></p> <p>View the output: <pre><code>view(markers_6)\n</code></pre> </p> <p>It's convenient to add a <code>cluster</code> column and a <code>gene</code> column for ease of filtering and combining with other data.  <pre><code>markers_6$cluster = 6\nmarkers_6$gene = rownames(markers_6)\n</code></pre> A common step after calculating markers is to filter the marker table by the significance level and magnitude of the fold change. In this table there are 6 columns giving a measure of significance for each gene: - <code>stim_p_val</code>, <code>ctrl_p_val</code> - the raw p-value for each group - <code>stim_p_val_adj</code>, <code>ctrl_p_val_adj</code> - the FDR adjusted p-value for each group - <code>max_pval</code> - largest p-value of the two groups - <code>minimump_p_val</code> - combined p-value, using package <code>metap</code></p> <p>And two giving fold change values: - <code>stim_avg_log2FC</code> and <code>ctrl_avg_log2FC</code>: log fold-change of the average expression between the two cluster 6 and all other clusters. Positive values indicate that the feature is more highly expressed in the cluster 6.</p> <p>The following command filters markers by <code>minimump_p_val</code> and selects the top 3 by <code>stim_avg_log2FC</code>: <pre><code>markers_6_top5 = markers_6 %&gt;%\n  dplyr::filter(minimump_p_val&lt;0.05) %&gt;%\n  slice_max(order_by=stim_avg_log2FC, n=5)\n</code></pre></p> <p>Let's plot these: <pre><code>DotPlot(integ_seurat, features=markers_6_top5$gene) + \n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n</code></pre> </p> Can you write a for loop that runs <code>FindConservedMarkers</code> for all clusters and outputs a single table?"},{"location":"intro_to_single_cell_rnaseq/07_differential_expression/#differentially-expressed-genes","title":"Differentially Expressed Genes","text":"<p>We are also interested in gene expression changes between the conditions within each cluster/cell-type. As mentioned in lecture, experiments designed to test differences between conditions should have ideally have multiple replicates of each condition and intra-individual variation should be taken into account. One solution is to use mixed-effects models MAST. </p> <p>For our tutorial dataset, with only one replicate in each condition, we can't apply these these methods and so our <code>p-values</code> will suffer from pseudoreplication bias. Findings should be considered hypothesis generating. </p> <p>To demonstrate, we'll use <code>FindMarkers</code> on cluster 6 cells to find differences between <code>ctrl</code> and <code>stim</code>. First, select the cluster 6 cells in a new Seurat object using <code>subset</code>: <pre><code>cluster_6 = subset(integ_seurat, ident = 6) \n</code></pre></p> <p>Set the identities to be \"sample\":</p> <pre><code>Idents(cluster_6) = \"sample\"\n</code></pre> <p>Run <code>FindMarkers</code>, where we are testing the <code>stim</code> cells against the <code>ctrl</code> cells, so <code>stim</code> will be listed first.  <pre><code>deg = FindMarkers(cluster_6,\n                   ident.1 = \"stim\",\n                   ident.2 = \"ctrl\",\n                   only.pos = FALSE)\n</code></pre> View the results:</p> <p><pre><code>view(deg)\n</code></pre> </p> <p>Select the top 5 by <code>avg_log2FC</code>:</p> <pre><code>deg_top5 = deg %&gt;%\n  dplyr::filter(p_val_adj&lt;0.05) %&gt;%\n  slice_max(order_by=avg_log2FC, n=5) %&gt;%\n  rownames_to_column(\"gene\")\n</code></pre> <p>Use <code>DotPlot</code> to visualize expression in two condition groups: <pre><code>DotPlot(cluster_6, features=deg_top5$gene) + \n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n</code></pre> </p>"},{"location":"intro_to_single_cell_rnaseq/07_differential_expression/#gene-ontology-functional-enrichment-optional","title":"Gene Ontology Functional Enrichment (Optional):","text":"<p>The above functions give us lists of genes that help us to understand the behavior of cell types in our two conditions. Here we demonstrate the use of overrepresentation analysis together with the Gene Ontology database to understand the biological processes represented by the list of cluster 6 marker genes. Some details about overrepresentation analysis are available here.</p> <p>Here, we'll select the top 100 genes by <code>stim_avg_log2FC</code>.  <pre><code>markers_6_top100 = markers_6 %&gt;%\n  dplyr::filter(minimump_p_val&lt;0.05) %&gt;%\n  slice_max(order_by=stim_avg_log2FC, n=100)\n</code></pre></p> <p>Load additional packages - clusterProfiler: Library for functional enrichment of omics data - org.Hs.eg.db: Bioconductor package providing genome wide annotation for Human</p> <pre><code>library(clusterProfiler)\nlibrary(org.Hs.eg.db)\n</code></pre> <p>Run the <code>enrichGO</code> function, which will run a Gene Ontology Enrichment Analysis: <pre><code>ego &lt;- enrichGO(gene = markers_6_top100$gene,\n                     OrgDb = org.Hs.eg.db,\n                     keyType=\"SYMBOL\",\n                     ont = \"BP\",\n                     universe=rownames(integ_seurat@assays$RNA@counts))\n</code></pre></p> <p>Use <code>clusterProfiler::dotplot</code> to visualize the results: <pre><code>dotplot(ego,\n        font.size=10, \n        show=10,\n        orderBy=\"Count\")\n</code></pre> </p> <p>Similar to the <code>Seurat::DotPlot</code>, <code>clusterProfiler::dotplot</code> is able to visualize two metrics, which are the adjusted p-value and the <code>Count</code>, number of genes in the input set contributing to the enrichment.</p>"}]}